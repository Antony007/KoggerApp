#include "plotcash.h"
#include <QPainterPath>

#include <core.h>
extern Core core;

Epoch::Epoch() {
    _charts.clear();
    flags.distAvail = false;
}

void Epoch::setEvent(int timestamp, int id, int unixt) {
    _eventTimestamp_us = timestamp;
    _eventUnix = unixt;
    _eventId = id;
    _time = DateTime(unixt, timestamp*1000);
    flags.eventAvail = true;
}

void Epoch::setEncoder(float encoder) {
    _encoder.validMask |= 1;
    _encoder.e1 = encoder;
    flags.encoderAvail = true;
}


void Epoch::setChart(int16_t channel, QVector<uint8_t> data, float resolution, int offset) {
    _charts[channel].amplitude = data;
    _charts[channel].resolution = resolution;
    _charts[channel].offset = offset;
    _charts[channel].type = 1;
}

void Epoch::setComplexSignal16(int channel, QVector<Complex16> data) {
    _complex[channel].data = QByteArray((const char*)data.constData(), data.size()*sizeof(Complex16));
    _complex[channel].type = 2;
}

void Epoch::setDist(int dist) {
    _rangeFinders[0] = dist*0.001;
    flags.distAvail = true;
}

void Epoch::setRangefinder(int channel, float distance) {
    _rangeFinders[channel] = distance;
}

void Epoch::setDopplerBeam(IDBinDVL::BeamSolution *beams, uint16_t cnt) {
    for(uint16_t i = 0; i < cnt; i++) {
        _dopplerBeams[i] = beams[i];
    }
    //    setDist(beams[0].distance*1000.0f);
    _dopplerBeamCount = cnt;
}

void Epoch::setDVLSolution(IDBinDVL::DVLSolution dvlSolution) {
    _dvlSolution = dvlSolution;
    flags.isDVLSolutionAvail = true;
}

void Epoch::setPositionLLA(double lat, double lon, LLARef* ref, uint32_t unix_time, int32_t nanosec) {
    Q_UNUSED(ref);

    _positionGNSS.time = DateTime(unix_time, nanosec);
    _positionGNSS.lla.latitude = lat;
    _positionGNSS.lla.longitude = lon;

    flags.posAvail = true;
}

void Epoch::setExternalPosition(Position position) {
    _positionExternal = position;
}

void Epoch::setPositionRef(LLARef* ref) {
    if(ref != NULL && ref->isInit) {
        _positionGNSS.LLA2NED(ref);
    }
}

void Epoch::setGnssVelocity(double h_speed, double course) {
    _GnssData.hspeed = h_speed;
    _GnssData.course = course;
}

void Epoch::setTime(DateTime time) {
    Q_UNUSED(time);
}

void Epoch::setTime(int year, int month, int day, int hour, int min, int sec, int nanosec) {
    Q_UNUSED(year);
    Q_UNUSED(month);
    Q_UNUSED(day);
    Q_UNUSED(hour);
    Q_UNUSED(min);
    Q_UNUSED(sec);
    Q_UNUSED(nanosec);
}


void Epoch::setTemp(float temp_c) {
    m_temp_c = temp_c;
    flags.tempAvail = true;
}

void Epoch::setEncoders(int16_t enc1, int16_t enc2, int16_t enc3, int16_t enc4, int16_t enc5, int16_t enc6) {
    _encoder.e1 = enc1;
    _encoder.e2 = enc2;
    _encoder.e3 = enc3;
    _encoder.e4 = enc4;
    _encoder.e5 = enc5;
    _encoder.e6 = enc6;
    _encoder.validMask = (uint16_t)0x111111;
}

void Epoch::setAtt(float yaw, float pitch, float roll) {
    _attitude.yaw = yaw;
    _attitude.pitch = pitch;
    _attitude.roll = roll;
}

void Epoch::doBottomTrack2D(Echogram &chart, bool is_update_dist) {
    Q_UNUSED(chart);
    Q_UNUSED(is_update_dist);
}

void Epoch::doBottomTrackSideScan(Echogram &chart, bool is_update_dist) {
    Q_UNUSED(chart);
    Q_UNUSED(is_update_dist);
}

Dataset::Dataset() : lastBoatTrackEpoch_(0), lastBottomTrackEpoch_(0) {
    resetDataset();
}

void Dataset::getMaxDistanceRange(float *from, float *to, int channel1, int channel2) {
    const int sz = size();
    float channel1_max = 0;
    float channel2_max = 0;
    for(int iepoch = 0; iepoch < sz; iepoch++) {
        Epoch* epoch = fromIndex(iepoch);
        if(epoch != NULL) {
            if(epoch->chartAvail(channel1)) {
                float range = epoch->chart(channel1)->range();
                if(channel1_max < range) {
                    channel1_max = range;
                }
            }

            if(epoch->chartAvail(channel2)) {
                float range = epoch->chart(channel2)->range();
                if(channel2_max < range) {
                    channel2_max = range;
                }
            }
        }
    }

    if(channel1_max > 0) {
        if(channel2_max > 0) {
            *from = -channel1_max;
            *to = channel2_max;
        } else {
            *from = 0;
            *to = channel1_max;
        }

    } else {
        *from = NAN;
        *to = NAN;
    }
}

QVector<QVector3D> Dataset::boatTrack() const
{
    return _boatTrack;
}

int Dataset::getLastBottomTrackEpoch() const
{
    return lastBottomTrackEpoch_;
}

void Dataset::addEvent(int timestamp, int id, int unixt) {
    lastEventTimestamp = timestamp;
    lastEventId = id;

    //    if(poolLastIndex() < 0) {
    makeNewEpoch();
    //    }

    _pool[endIndex()].setEvent(timestamp, id, unixt);
    emit dataUpdate();
}

void Dataset::addEncoder(float encoder) {
    _lastEncoder = encoder;
    if(endIndex() < 0) {
        makeNewEpoch();
    }
    //    poolAppend();
    _pool[endIndex()].setEncoder(_lastEncoder);
    emit dataUpdate();
}

void Dataset::addTimestamp(int timestamp) {
    Q_UNUSED(timestamp);
}

void Dataset::addChart(int16_t channel, QVector<uint8_t> data, float resolution, float offset) {
    if(data.size() <= 0 || resolution == 0) { return; }

    int pool_index = endIndex();

    if(pool_index < 0
            //             || _pool[pool_index].eventAvail() == false
            || _pool[pool_index].chartAvail(channel)) {
        makeNewEpoch();
        pool_index = endIndex();
    }

    _pool[endIndex()].setChart(channel, data, resolution, offset);

    validateChannelList(channel);

    emit dataUpdate();
}

void Dataset::addComplexSignal(QByteArray data, uint8_t type) {
    Q_UNUSED(type);

    int pool_index = endIndex();

    if(pool_index < 0 || !_pool[pool_index].isComplexSignalAvail()) {
        makeNewEpoch();
        pool_index = endIndex();
    }

    const int ch_number = 4;

    Complex16* compelex_data = (Complex16*)data.data();
    int size = data.size()/sizeof(Complex16)/ch_number;

    // qDebug("size %i", size);

    // if(size > 2048) { size = 2048; }

    // int16_t r_flt[74] = {587, -938, -150, 999, 684, -754, -684, 666, 992, 297, -857, -754, 344, 998, 882, 25, -830, -934, -309, 503, 965, 993, 684, 112, -470, -863, -999, -915, -684, -402, -112, 137, 332, 481, 577, 627, 647, 627, 567, 470, 332, 137, -112, -379, -656, -888, -997, -929, -647, -175, 379, 844, 915, 437, -285, -876, -951, -402, 459, 954, 285, -666, -979, -285, 737, 546, -587, -958, -25, 934, -150, -998, -212, 942};
    // int16_t i_flt[74] = {809, 344, -988, -12, 728, 656, -728, -745, -125, 954, 514, -656, -938, -62, 470, 999, 556, -356, -951, -863, -260, 112, 728, 993, 882, 503, 37, -402, -728, -915, -993, -990, -942, -876, -816, -778, -762, -778, -823, -882, -942, -990, -993, -925, -754, -459, -75, 368, 762, 984, 925, 535, -402, -899, -958, -481, 309, 915, 888, -297, -958, -745, 199, 958, 675, -837, -809, 285, 999, -356, -988, -50, 977, 332};

    // int16_t r_flt[1201] = {10,-860,-872,-18,853,881,41,-838,-897,-81,813,918,135,-776,-942,-205,726,966,289,-660,-986,-385,576,998,490,-471,-997,-602,345,975,714,-196,-928,-819,27,849,909,157,-733,-972,-351,578,999,545,-384,-978,-724,155,900,871,97,-758,-969,-359,553,999,607,-291,-946,-815,-10,802,955,326,-567,-999,-621,257,928,854,97,-735,-984,-454,431,978,759,-51,-821,-954,-351,520,992,707,-114,-849,-942,-326,532,993,714,-93,-830,-956,-381,471,980,777,14,-758,-986,-509,328,933,878,205,-610,-998,-692,93,812,973,466,-357,-937,-881,-231,572,992,750,10,-735,-995,-602,183,849,963,454,-345,-922,-910,-320,472,965,851,205,-567,-987,-796,-116,634,996,752,53,-676,-999,-724,-18,696,999,714,11,-697,-999,-724,-32,676,998,752,81,-634,-993,-796,-157,567,978,851,259,-472,-947,-910,-385,345,890,963,527,-183,-797,-995,-677,-10,660,992,819,232,-471,-937,-934,-466,230,812,995,692,53,-609,-978,-878,-359,328,860,986,651,14,-628,-980,-881,-381,291,830,995,714,116,-532,-945,-942,-528,114,706,992,854,352,-297,-820,-998,-759,-205,431,890,984,677,98,-519,-928,-966,-621,-32,567,945,955,597,10,-578,-946,-956,-607,-32,553,933,969,651,98,-489,-900,-987,-724,-205,383,837,999,815,352,-230,-733,-987,-909,-528,27,572,928,980,714,219,-344,-797,-997,-881,-491,50,576,922,986,751,289,-257,-726,-978,-942,-630,-136,395,812,996,897,545,42,-471,-853,-999,-873,-510,-10,489,858,999,878,528,42,-452,-830,-996,-910,-597,-136,357,761,978,958,708,289,-196,-634,-922,-995,-839,-491,-32,431,797,985,954,714,320,-141,-572,-879,-999,-909,-630,-222,230,634,908,999,891,607,205,-234,-628,-900,-999,-910,-651,-272,154,552,849,991,956,752,417,11,-395,-733,-945,-996,-882,-621,-260,141,519,812,975,984,839,565,205,-183,-543,-820,-975,-986,-854,-599,-260,114,471,761,945,999,918,714,417,66,-290,-609,-849,-980,-987,-873,-652,-352,-12,328,628,853,978,991,891,692,417,98,-230,-532,-776,-937,-999,-958,-820,-599,-320,-11,297,575,797,942,999,963,839,640,385,98,-196,-471,-706,-879,-978,-996,-934,-796,-597,-352,-81,193,452,676,849,959,999,969,872,715,510,272,19,-234,-471,-676,-837,-946,-996,-986,-918,-796,-630,-429,-206,27,257,471,659,812,922,985,998,963,882,759,603,420,219,11,-196,-393,-572,-725,-849,-937,-987,-999,-973,-911,-816,-692,-546,-381,-206,-25,154,328,489,634,758,858,932,980,999,991,956,897,816,715,597,467,327,181,33,-114,-257,-393,-519,-634,-734,-820,-890,-942,-978,-996,-998,-984,-954,-911,-854,-786,-708,-621,-528,-429,-327,-222,-116,-11,92,193,290,383,470,552,627,696,758,812,859,899,932,959,978,991,998,999,995,986,973,955,934,909,882,852,820,786,751,715,678,640,603,565,528,491,455,420,385,352,320,289,260,232,206,181,158,136,116,98,81,67,54,42,33,25,19,14,12,11,12,14,19,25,33,42,54,67,81,98,116,136,158,181,206,232,260,289,320,352,386,420,455,491,528,565,603,640,678,715,751,786,820,852,882,909,934,955,973,986,995,999,998,991,978,959,932,899,859,812,757,696,627,552,470,383,290,193,91,-11,-117,-222,-327,-429,-528,-622,-708,-786,-854,-911,-954,-984,-998,-996,-978,-942,-890,-820,-734,-633,-519,-392,-256,-113,33,181,327,467,597,715,816,897,956,991,999,980,932,858,757,633,489,327,154,-25,-206,-382,-546,-693,-816,-911,-973,-999,-987,-936,-848,-725,-571,-392,-195,11,220,420,603,760,882,963,998,985,922,812,659,471,256,26,-206,-429,-631,-797,-918,-986,-996,-946,-837,-675,-470,-234,19,273,510,715,872,969,999,958,848,675,452,192,-82,-353,-597,-797,-934,-996,-978,-879,-705,-471,-195,98,386,641,839,963,999,942,797,575,296,-11,-320,-600,-820,-958,-999,-936,-775,-531,-229,98,418,693,892,991,978,852,627,327,-12,-353,-652,-873,-988,-980,-848,-609,-290,67,418,715,918,999,944,760,470,113,-261,-600,-854,-986,-975,-820,-542,-182,206,566,839,984,975,812,519,141,-261,-622,-882,-996,-944,-732,-395,11,418,753,956,991,848,552,153,-273,-652,-911,-999,-899,-627,-233,206,608,892,999,908,633,229,-222,-631,-909,-999,-879,-571,-141,321,715,954,985,797,430,-33,-492,-839,-996,-922,-633,-195,290,708,958,978,760,355,-137,-598,-911,-996,-830,-451,43,529,878,999,858,488,-11,-511,-873,-999,-852,-470,43,546,897,996,812,395,-137,-631,-942,-978,-725,-256,290,751,986,922,575,49,-492,-882,-996,-797,-343,220,715,980,927,571,26,-529,-909,-987,-732,-229,353,816,999,837,382,-207,-725,-988,-899,-488,99,652,969,932,552,-34,-608,-957,-946,-577,12,598,955,944,566,-34,-622,-966,-927,-518,99,678,984,889,430,-207,-760,-998,-820,-296,353,854,992,705,113,-529,-942,-944,-531,117,715,995,829,289,-382,-882,-979,-627,15,652,986,859,327,-360,-878,-978,-608,54,693,995,812,229,-468,-934,-936,-470,233,820,992,659,-12,-678,-996,-796,-182,529,963,889,343,-386,-911,-946,-471,261,852,978,566,-159,-797,-993,-633,82,753,998,675,-34,-725,-999,-695,13,715,999,695,-19,-725,-999,-675,55,753,996,633,-117,-797,-987,-566,207,852,965,470,-321,-911,-922,-343,456,963,848,182,-604,-996,-734,12,752,992,571,-233,-882,-936,-355,467,973,811,91,-693,-998,-608,207,879,932,326,-511,-986,-757,16,778,979,470,-382,-957,-829,-91,715,993,531,-328,-942,-848,-113,709,992,518,-353,-955,-820,-49,760,978,430,-456,-984,-734,99,854,927,256,-622,-999,-566,328,955,800,-12,-816,-946,-289,609,999,551,-361,-969,-757,99,872,899,153,-725,-978,-382,547,999,577,-353,-973,-732,159,910,848,26,-820,-927,-195,715,975,343,-604,-996,-470,492,998,574,-386,-986,-658,291,966,725,-207,-942,-775,137,918,811,-83,-898,-836,43,882,852,-20,-873,-859,12};
    // int16_t i_flt[1201] = {999,509,-487,-999,-521,471,999,545,-441,-996,-582,396,990,630,-335,-978,-687,257,957,750,-163,-922,-817,51,871,881,76,-798,-938,-219,699,980,371,-572,-999,-527,416,987,679,-230,-936,-815,20,838,923,205,-689,-987,-435,490,995,651,-245,-933,-832,-32,794,956,322,-578,-999,-597,295,945,823,32,-783,-966,-371,520,995,677,-176,-890,-901,-205,650,998,570,-298,-936,-854,-118,706,993,527,-335,-945,-846,-115,699,995,556,-291,-924,-881,-197,628,999,651,-163,-860,-944,-359,478,978,792,53,-721,-995,-582,230,884,933,348,-471,-972,-819,-118,660,999,677,-90,-797,-982,-527,268,890,938,385,-412,-947,-881,-259,523,978,823,157,-604,-993,-772,-81,658,998,736,32,-689,-999,-717,-11,699,999,717,18,-689,-999,-736,-53,658,996,772,116,-604,-987,-823,-205,523,965,881,320,-412,-922,-938,-454,268,849,983,602,-90,-735,-999,-750,-118,572,972,881,348,-357,-884,-973,-582,92,721,998,792,205,-478,-933,-944,-510,163,758,999,777,198,-471,-924,-956,-556,92,699,993,846,326,-335,-849,-993,-707,-118,519,935,954,571,-51,-650,-978,-902,-455,176,735,995,854,371,-257,-783,-999,-823,-326,295,802,999,815,322,-291,-794,-999,-833,-359,244,758,995,871,435,-155,-689,-978,-923,-545,20,578,935,973,679,157,-415,-849,-999,-819,-371,196,699,975,938,602,77,-471,-870,-998,-817,-385,162,660,957,966,687,205,-334,-776,-990,-918,-582,-81,441,837,999,881,521,18,-487,-859,-999,-871,-512,-18,478,849,999,891,556,81,-412,-801,-990,-934,-648,-205,285,706,957,980,773,385,-89,-543,-870,-999,-902,-602,-170,297,699,947,989,820,476,32,-415,-776,-975,-973,-773,-417,20,452,794,978,972,778,435,11,-412,-758,-962,-987,-833,-528,-129,291,658,908,999,918,679,326,-79,-471,-783,-965,-989,-854,-582,-219,176,543,824,978,983,839,571,219,-162,-519,-800,-965,-993,-882,-648,-326,37,395,699,908,997,956,792,528,198,-154,-487,-758,-935,-999,-944,-778,-521,-205,131,452,721,908,995,973,846,630,349,32,-284,-572,-800,-947,-999,-954,-817,-603,-332,-32,268,543,767,922,995,980,881,708,476,206,-79,-356,-603,-801,-935,-996,-981,-891,-736,-528,-283,-19,244,489,699,859,962,999,972,882,736,545,322,81,-162,-395,-603,-776,-903,-978,-999,-966,-881,-751,-582,-385,-170,50,268,471,650,797,907,975,999,980,919,820,687,528,349,158,-37,-230,-412,-577,-721,-837,-924,-978,-999,-987,-944,-872,-773,-652,-512,-360,-198,-33,131,290,440,577,699,801,884,944,983,999,993,966,919,854,773,678,571,455,333,206,77,-50,-176,-297,-412,-519,-617,-705,-783,-848,-902,-944,-974,-993,-999,-995,-981,-956,-923,-882,-833,-778,-717,-652,-582,-510,-436,-360,-283,-206,-129,-54,19,92,162,229,294,356,415,471,523,572,617,659,698,734,767,797,824,848,870,890,907,922,935,947,957,965,972,978,983,987,990,993,995,996,997,998,999,999,999,999,999,999,999,999,999,999,999,999,999,998,997,996,995,993,990,987,983,978,972,965,957,947,935,922,907,890,870,848,824,797,767,734,698,659,617,572,522,470,415,356,294,229,162,92,19,-54,-130,-206,-283,-360,-436,-510,-582,-652,-717,-778,-833,-882,-923,-956,-981,-995,-999,-993,-974,-944,-902,-848,-782,-705,-617,-519,-411,-297,-175,-50,77,206,333,455,571,678,773,854,919,966,993,999,983,944,884,801,698,577,440,290,131,-33,-198,-360,-513,-652,-773,-872,-944,-988,-999,-978,-924,-837,-720,-577,-411,-229,-37,158,349,528,687,820,919,980,999,975,907,797,649,470,267,50,-171,-386,-583,-751,-881,-966,-999,-978,-902,-775,-603,-395,-161,82,323,546,737,882,972,999,961,859,698,488,244,-19,-283,-528,-737,-892,-981,-996,-935,-801,-603,-356,-78,206,476,708,881,980,995,922,767,542,267,-33,-333,-603,-818,-954,-999,-947,-799,-571,-284,33,349,631,846,973,995,908,720,452,130,-206,-522,-778,-944,-999,-935,-757,-486,-154,198,528,793,956,997,908,698,395,36,-327,-649,-882,-993,-965,-799,-519,-161,220,572,839,983,978,824,542,175,-220,-583,-854,-990,-965,-782,-470,-78,327,680,918,999,908,657,290,-130,-528,-833,-988,-961,-757,-411,12,436,778,972,978,793,452,19,-418,-773,-973,-974,-775,-415,33,476,820,990,946,698,296,-171,-603,-902,-999,-870,-542,-89,386,773,980,956,705,284,-206,-649,-934,-990,-801,-411,82,557,892,999,848,477,-19,-513,-872,-999,-859,-486,19,522,882,999,837,439,-82,-583,-918,-990,-775,-333,206,688,966,956,659,161,-386,-818,-998,-870,-470,78,603,939,975,698,195,-372,-820,-999,-848,-414,158,680,973,935,577,19,-546,-923,-978,-688,-153,436,872,995,757,243,-360,-833,-999,-793,-289,323,816,999,801,293,-327,-824,-999,-782,-256,373,854,995,734,175,-456,-902,-978,-649,-49,572,955,935,518,-120,-709,-993,-848,-333,327,847,993,698,91,-557,-957,-923,-470,199,778,999,757,161,-511,-944,-932,-477,207,793,998,720,91,-583,-973,-883,-355,350,882,972,571,-120,-751,-999,-734,-88,603,983,848,267,-456,-939,-922,-411,321,882,965,522,-207,-824,-987,-603,117,773,996,657,-55,-737,-999,-688,19,718,999,698,-13,-718,-999,-688,33,737,998,657,-82,-773,-993,-603,158,824,978,522,-261,-882,-946,-411,386,939,889,267,-529,-983,-796,-88,678,999,658,-120,-820,-972,-470,350,934,883,228,-583,-995,-720,55,793,978,476,-361,-945,-859,-161,653,999,627,-199,-882,-923,-289,558,995,698,-117,-847,-944,-333,529,993,704,-120,-854,-935,-296,572,998,649,-207,-902,-889,-175,678,995,518,-373,-966,-782,34,824,944,293,-598,-999,-577,323,957,793,-34,-834,-932,-243,653,995,488,-437,-988,-688,207,923,836,19,-816,-935,-228,681,987,414,-529,-999,-571,373,980,698,-221,-939,-796,78,882,870,49,-818,-922,-161,752,956,256,-688,-978,-333,631,990,394,-583,-996,-439,547,999,470,-522,-999,-486,511,999};

    int16_t r_flt[1251] = {5,-840,-908,-137,758,958,281,-651,-991,-432,516,999,584,-353,-974,-727,164,910,852,44,-801,-945,-265,644,995,486,-440,-988,-690,196,915,857,75,-769,-966,-354,552,999,616,-275,-939,-830,-41,780,966,368,-526,-996,-665,198,902,887,168,-682,-995,-525,354,957,814,40,-763,-978,-442,431,975,777,-9,-788,-972,-427,436,974,787,18,-763,-983,-482,369,951,843,125,-681,-998,-601,223,889,924,307,-524,-987,-761,-5,753,990,545,-272,-903,-918,-310,506,981,796,79,-689,-999,-647,130,822,974,490,-310,-910,-921,-340,457,962,855,206,-571,-989,-786,-93,656,998,724,5,-715,-999,-675,56,753,996,643,-93,-773,-994,-629,104,776,994,635,-89,-762,-997,-661,49,731,999,705,16,-680,-998,-763,-108,605,986,830,224,-502,-956,-898,-360,367,900,957,512,-199,-806,-994,-669,0,667,993,815,225,-476,-939,-932,-462,235,815,995,688,47,-615,-980,-873,-350,339,866,984,639,-3,-643,-984,-870,-357,318,847,991,688,76,-568,-959,-924,-482,170,747,998,816,283,-370,-864,-990,-697,-110,520,933,958,587,-24,-625,-969,-920,-500,119,690,986,890,444,-174,-724,-991,-875,-423,189,728,991,880,439,-164,-705,-985,-902,-490,99,652,968,937,572,5,-561,-931,-974,-679,-150,428,860,998,798,331,-246,-740,-988,-910,-534,14,557,919,985,737,256,-303,-768,-991,-907,-543,-13,518,892,996,801,368,-173,-661,-955,-969,-703,-234,299,747,982,940,635,154,-367,-787,-990,-924,-609,-130,380,789,990,930,628,164,-339,-756,-979,-954,-690,-254,242,679,947,985,784,395,-85,-545,-875,-999,-891,-576,-130,343,738,965,976,770,395,-65,-510,-844,-995,-933,-674,-273,182,599,891,999,904,627,225,-220,-621,-898,-999,-907,-640,-252,181,580,869,996,939,711,354,-64,-470,-791,-972,-982,-822,-521,-132,277,639,893,998,938,726,397,5,-385,-713,-929,-999,-915,-691,-363,18,395,712,924,999,931,728,424,60,-309,-635,-872,-990,-973,-826,-570,-240,119,462,744,931,999,943,770,503,177,-169,-494,-759,-933,-999,-950,-792,-546,-240,90,410,683,882,986,986,883,688,424,119,-196,-491,-736,-909,-993,-981,-877,-692,-443,-156,144,430,676,862,972,998,939,802,598,347,69,-212,-476,-701,-870,-972,-999,-951,-833,-654,-429,-175,89,346,578,769,907,984,996,943,830,665,460,227,-17,-259,-484,-680,-835,-941,-994,-991,-934,-827,-677,-492,-283,-61,162,376,570,735,864,952,995,993,946,858,733,577,399,206,5,-193,-383,-556,-707,-830,-921,-978,-999,-985,-938,-858,-751,-620,-470,-307,-135,38,209,373,524,659,774,868,937,981,999,992,960,906,831,737,627,505,373,234,93,-49,-188,-323,-449,-566,-671,-763,-841,-904,-951,-982,-998,-998,-983,-954,-912,-859,-794,-720,-639,-550,-456,-359,-259,-157,-56,44,142,238,329,417,499,575,646,710,768,819,864,902,933,958,977,990,997,999,996,989,977,961,942,919,894,866,836,805,771,737,702,666,630,594,558,522,486,452,418,385,352,322,292,263,236,210,186,163,141,121,102,86,71,57,45,34,26,18,13,9,6,6,6,9,13,18,26,34,45,57,71,86,102,121,141,163,186,210,236,263,292,322,353,385,418,452,486,522,558,594,630,666,702,737,772,805,836,866,894,919,942,961,977,989,996,999,997,990,977,958,933,902,864,819,768,710,646,575,499,416,329,237,142,44,-56,-158,-259,-359,-457,-550,-639,-721,-794,-859,-912,-954,-983,-998,-998,-982,-951,-904,-841,-763,-671,-566,-449,-323,-188,-49,93,235,373,505,627,737,831,906,960,992,999,981,937,867,774,659,524,372,209,37,-136,-307,-471,-620,-751,-859,-938,-985,-999,-978,-921,-829,-707,-556,-382,-192,6,206,399,578,733,858,946,993,995,952,864,735,570,376,162,-61,-283,-492,-677,-827,-934,-991,-994,-941,-835,-680,-484,-258,-16,228,460,665,830,943,996,984,907,769,578,346,89,-175,-430,-654,-833,-951,-999,-972,-870,-701,-476,-212,69,347,599,802,939,998,972,862,676,429,144,-156,-444,-692,-877,-981,-992,-909,-736,-491,-196,119,425,688,883,986,986,882,683,409,89,-241,-547,-793,-950,-999,-933,-758,-493,-169,177,503,770,943,999,931,744,462,118,-240,-570,-826,-973,-990,-872,-635,-309,61,424,729,931,999,923,712,395,17,-363,-691,-915,-999,-929,-713,-384,6,397,726,939,998,893,639,277,-132,-521,-822,-982,-972,-791,-470,-64,354,711,939,996,869,580,181,-253,-640,-907,-999,-898,-620,-220,225,627,904,999,891,599,181,-274,-674,-933,-995,-843,-510,-64,396,771,977,965,737,342,-131,-577,-891,-999,-875,-545,-85,396,784,985,947,678,242,-254,-690,-954,-979,-755,-339,165,628,930,989,789,380,-131,-609,-924,-990,-786,-367,155,635,940,982,746,298,-235,-703,-969,-955,-661,-172,368,801,996,892,518,-14,-544,-907,-991,-767,-303,257,738,985,919,556,13,-534,-910,-988,-739,-245,331,799,998,859,427,-151,-680,-974,-930,-561,6,572,937,968,651,99,-490,-902,-985,-705,-163,439,880,991,728,188,-424,-876,-991,-723,-173,445,890,985,690,118,-501,-921,-969,-624,-23,587,958,933,520,-111,-697,-990,-864,-369,284,816,998,747,169,-482,-924,-958,-567,77,689,992,847,317,-357,-870,-984,-642,-2,640,984,866,338,-350,-874,-980,-615,47,688,995,815,234,-462,-932,-938,-476,226,816,993,666,-1,-669,-994,-805,-198,513,958,899,366,-362,-899,-956,-501,225,830,986,604,-108,-763,-998,-680,17,706,999,731,49,-662,-997,-762,-88,636,995,775,104,-630,-994,-772,-92,643,997,753,55,-676,-999,-715,6,725,998,655,-94,-786,-988,-570,207,855,962,456,-341,-921,-909,-310,491,974,821,130,-647,-999,-688,79,796,981,506,-310,-918,-902,-271,546,990,752,-6,-761,-987,-523,307,924,888,222,-601,-998,-680,126,844,951,368,-483,-983,-762,19,788,974,435,-428,-972,-787,-8,777,975,431,-443,-978,-763,41,814,956,354,-526,-995,-681,169,887,902,197,-665,-996,-525,369,966,779,-42,-831,-939,-274,617,999,551,-355,-966,-768,75,857,914,195,-690,-988,-439,487,995,643,-266,-946,-800,45,852,910,164,-728,-974,-352,585,999,515,-433,-991,-650,282,958,758,-139,-908,-840,6};
    int16_t i_flt[1251] = {999,541,-417,-990,-651,284,959,758,-131,-901,-856,-39,811,935,224,-686,-986,-413,523,999,598,-324,-964,-764,96,873,897,151,-723,-980,-403,515,997,638,-255,-935,-833,-38,787,961,342,-556,-999,-625,256,929,850,85,-746,-980,-430,460,985,730,-99,-850,-934,-289,580,999,645,-204,-896,-901,-219,629,999,615,-231,-904,-899,-225,615,999,646,-181,-875,-929,-306,537,992,731,-53,-799,-974,-457,382,951,851,155,-648,-999,-657,138,837,962,428,-395,-950,-862,-192,604,996,723,-29,-762,-991,-569,224,871,950,414,-388,-940,-889,-271,518,978,820,147,-617,-995,-754,-46,689,999,698,-28,-737,-998,-657,78,765,995,633,-102,-776,-994,-630,100,771,995,646,-73,-749,-998,-681,19,708,999,732,59,-646,-994,-796,-163,557,974,864,290,-438,-932,-930,-435,287,858,979,591,-103,-743,-999,-744,-110,578,974,879,343,-362,-886,-971,-578,98,725,998,788,197,-486,-936,-940,-499,176,768,999,765,176,-492,-933,-948,-530,126,725,997,822,282,-381,-875,-985,-663,-54,577,959,928,502,-136,-716,-993,-853,-358,285,809,999,780,244,-390,-865,-992,-723,-166,454,895,984,689,127,-482,-905,-981,-684,-128,474,898,986,708,169,-430,-871,-995,-758,-249,348,819,999,827,364,-223,-733,-988,-903,-509,55,601,943,969,672,153,-414,-845,-999,-830,-393,168,674,966,952,640,129,-420,-839,-999,-855,-451,87,598,929,984,749,295,-243,-710,-972,-954,-664,-187,340,772,987,930,616,135,-380,-793,-991,-924,-613,-140,367,777,986,940,654,202,-298,-723,-967,-970,-734,-319,172,620,918,996,837,482,15,-453,-816,-991,-939,-674,-258,213,636,918,997,859,536,98,-358,-738,-961,-983,-800,-453,-14,425,778,974,975,783,438,9,-420,-767,-967,-983,-814,-493,-82,342,703,935,997,882,610,232,-184,-568,-853,-991,-960,-768,-449,-56,344,687,917,999,922,700,368,-18,-402,-722,-931,-999,-918,-701,-382,-8,364,684,905,998,950,772,488,138,-228,-562,-821,-970,-992,-886,-667,-364,-16,332,637,863,984,985,869,650,357,23,-311,-609,-837,-970,-995,-912,-729,-469,-160,163,469,724,905,992,980,870,675,416,117,-190,-478,-721,-896,-987,-989,-902,-736,-506,-233,57,342,597,800,937,997,977,879,712,491,234,-39,-308,-553,-755,-902,-984,-995,-937,-815,-638,-419,-173,82,330,556,746,887,973,999,965,874,733,549,336,105,-129,-355,-561,-735,-870,-959,-998,-986,-926,-821,-677,-502,-304,-94,117,323,513,680,816,916,978,999,981,923,830,707,557,388,207,19,-166,-346,-512,-659,-784,-882,-951,-990,-999,-977,-927,-851,-751,-632,-496,-348,-193,-34,123,277,422,556,675,778,862,927,972,995,998,982,946,893,823,740,645,539,426,307,185,61,-61,-181,-297,-408,-511,-606,-693,-769,-834,-889,-933,-965,-987,-998,-999,-989,-971,-944,-908,-866,-817,-762,-703,-639,-572,-502,-431,-358,-284,-210,-136,-63,7,77,145,211,274,335,392,447,498,547,593,635,675,711,745,776,804,829,852,873,891,908,922,935,946,956,964,971,977,982,986,989,992,994,996,997,998,998,999,999,999,999,999,999,999,999,999,999,999,999,999,998,998,997,996,994,992,989,986,982,977,971,964,956,946,935,922,908,891,873,852,829,804,776,745,711,675,635,593,547,498,447,392,334,274,211,145,77,7,-64,-136,-210,-284,-358,-431,-503,-572,-640,-703,-763,-817,-866,-909,-944,-971,-989,-999,-998,-987,-965,-933,-889,-834,-769,-692,-606,-511,-408,-297,-181,-60,62,185,307,426,539,645,740,823,893,946,982,998,995,971,927,862,778,675,555,422,277,123,-34,-193,-348,-496,-632,-751,-851,-927,-977,-999,-990,-951,-882,-783,-659,-511,-345,-166,19,207,389,557,707,831,923,981,999,978,916,815,679,513,323,117,-95,-304,-502,-677,-821,-926,-986,-998,-959,-870,-735,-560,-355,-128,106,336,550,733,874,965,999,973,887,746,556,330,81,-173,-419,-638,-815,-938,-996,-984,-902,-755,-552,-307,-38,234,492,712,879,977,997,937,800,596,342,57,-234,-506,-736,-902,-989,-987,-895,-721,-478,-189,118,416,676,870,980,992,905,724,469,163,-161,-469,-729,-912,-995,-970,-836,-608,-311,24,357,651,869,985,984,863,637,331,-16,-364,-667,-886,-992,-970,-821,-562,-227,139,488,772,950,998,905,684,364,-8,-382,-701,-918,-999,-931,-722,-401,-18,368,700,922,999,917,686,343,-56,-449,-768,-960,-991,-853,-568,-184,232,610,882,997,934,702,341,-82,-493,-814,-983,-967,-767,-420,9,438,783,975,974,778,425,-14,-453,-800,-983,-961,-738,-358,99,536,860,997,918,636,213,-259,-674,-939,-991,-816,-453,16,483,838,996,918,619,171,-319,-734,-970,-966,-723,-298,203,654,940,986,777,366,-141,-613,-924,-991,-792,-380,136,617,930,987,771,339,-188,-664,-954,-971,-710,-243,295,749,985,929,597,86,-452,-855,-999,-839,-419,130,640,952,966,674,167,-393,-830,-999,-845,-413,154,672,969,943,600,55,-510,-903,-988,-732,-223,365,827,999,819,347,-249,-758,-995,-871,-429,170,708,986,897,473,-129,-685,-982,-905,-481,128,690,984,895,454,-167,-723,-992,-865,-389,244,780,999,808,284,-358,-854,-993,-716,-136,502,929,958,576,-55,-664,-985,-875,-380,283,823,997,724,125,-531,-948,-933,-491,177,766,999,768,176,-499,-941,-936,-485,198,788,998,725,97,-578,-972,-886,-361,344,879,973,577,-111,-745,-999,-742,-102,591,980,858,286,-436,-930,-932,-437,291,865,974,556,-164,-796,-994,-645,59,733,999,708,19,-682,-998,-749,-72,647,996,771,99,-630,-994,-776,-101,634,995,765,77,-657,-998,-736,-28,698,999,688,-47,-755,-995,-617,148,821,978,517,-271,-889,-939,-387,415,950,870,224,-570,-991,-761,-28,724,996,604,-193,-862,-950,-394,429,962,837,136,-658,-999,-647,155,851,951,381,-458,-974,-798,-52,732,991,536,-307,-929,-875,-180,646,999,615,-225,-900,-903,-231,615,999,628,-219,-902,-896,-204,646,999,579,-290,-935,-850,-98,731,985,459,-431,-980,-746,86,850,929,255,-626,-999,-555,343,961,786,-39,-834,-934,-254,639,997,514,-404,-980,-723,152,898,873,95,-765,-963,-323,599,998,522,-414,-986,-685,225,935,810,-40,-856,-901,-130,759,959,283,-652,-990,-417,542,999};


    for(int ich = 0; ich < ch_number; ich++) {
        QVector<uint8_t> chart(size);
        uint8_t* chart_data = chart.data();

        QVector<Complex16> signal(size);
        Complex16* signal_data = signal.data();


        for(int i  = 0; i < size; i++) {
            // compelex_data[i*ch_number + ich].real = 0;
            // compelex_data[i*ch_number + ich].imag = 0;
            chart_data[i] = compelex_data[i*ch_number + ich].logPow()*2.5;
            // chart_data[i] = log10(abs(compelex_data[i*ch_number + ich].real) + abs(compelex_data[i*ch_number + ich].imag))*20.0;

            // Complex16 ref = compelex_data[i*ch_number + 0].getBitOffsetedRight(8);
            // Complex16 sig = compelex_data[i*ch_number + ich].getBitOffsetedRight(8);

            // Complex16 cross = ref.mulConj(sig);
            // chart_data[i] = (cross.arg()/3.14f)*127+127;
            signal_data[i] = compelex_data[i*ch_number + ich];
        }

        for(int i  = 0; i < size - 1250; i++) {
            int32_t real = 0, imag = 0;
            for(int icc  = 0; icc < 1250; icc++) {
                real += signal_data[i+icc].real*r_flt[icc] + signal_data[i+icc].imag*i_flt[icc];
                imag += -signal_data[i+icc].real*i_flt[icc] + signal_data[i+icc].imag*r_flt[icc];
            }
            real/=74*1000;
            imag/=74*1000;

            chart_data[i] = Complex16(real, imag).logPow()*2.5;
        }

        addChart(ich, chart, 0.06, 0);
        _pool[endIndex()].setComplexSignal16(ich, signal);
    }

    //    updateImage(true);
    emit dataUpdate();
}

void Dataset::addDist(int dist) {
    int pool_index = endIndex();
    if(pool_index < 0 || _pool[pool_index].distAvail() == true) {
        makeNewEpoch();
        pool_index = endIndex();
    }

    _pool[endIndex()].setDist(dist);
    emit dataUpdate();
}

void Dataset::addUsblSolution(IDBinUsblSolution::UsblSolution data) {
    int pool_index = endIndex();
    if(pool_index < 0 || _pool[pool_index].isUsblSolutionAvailable() == true) {
        makeNewEpoch();
        pool_index = endIndex();
    }

    _pool[endIndex()].set(data);
    emit dataUpdate();
}

void Dataset::addDopplerBeam(IDBinDVL::BeamSolution *beams, uint16_t cnt) {
    int pool_index = endIndex();

    if(pool_index < 0 || (_pool[pool_index].isDopplerBeamAvail() == true)) { //
        makeNewEpoch();
    }

    pool_index = endIndex();

    _pool[endIndex()].setDopplerBeam(beams, cnt);
    emit dataUpdate();
}

void Dataset::addDVLSolution(IDBinDVL::DVLSolution dvlSolution) {
    int pool_index = endIndex();

    if(pool_index < 0 || (_pool[pool_index].isDopplerBeamAvail() == false)) { //
        makeNewEpoch();
        pool_index = endIndex();
    }

    _pool[endIndex()].setDVLSolution(dvlSolution);
    emit dataUpdate();
}

void Dataset::addAtt(float yaw, float pitch, float roll) {
    int pool_index = endIndex();
    if(pool_index < 0) {
        makeNewEpoch();
        pool_index = endIndex();
    }
    _pool[endIndex()].setAtt(yaw, pitch, roll);
    _lastYaw = yaw;
    _lastPitch = pitch;
    _lastRoll = roll;
    emit dataUpdate();
}

void Dataset::addPosition(double lat, double lon, uint32_t unix_time, int32_t nanosec) {

    int pool_index = endIndex();
    if(pool_index < 0) {
        makeNewEpoch();
        pool_index = endIndex();
    }

    _pool[pool_index].setPositionLLA(lat, lon, &_llaRef, unix_time, nanosec);
    Position pos = _pool[pool_index].getPositionGNSS();

    if(pos.lla.isCoordinatesValid() && !pos.ned.isCoordinatesValid()) {
        if(!_llaRef.isInit) {
            _llaRef = LLARef(pos.lla);
        }

        _pool[pool_index].setPositionRef(&_llaRef);
        _lastPositionGNSS = _pool[pool_index].getPositionGNSS();
    }

    emit dataUpdate();
    updateBoatTrack();
}

void Dataset::addGnssVelocity(double h_speed, double course) {
    int pool_index = endIndex();
    if(pool_index < 0) {
        makeNewEpoch();
        pool_index = endIndex();
    }

//    if(isfinite(_pool[pool_index].gnssHSpeed())) {
//        makeNewEpoch();
//        pool_index = endIndex();
//    }


    _pool[pool_index].setGnssVelocity(h_speed, course);
    emit dataUpdate();
}

void Dataset::addTemp(float temp_c) {

    lastTemperature = temp_c;

    int pool_index = endIndex();
    if(pool_index < 0) {
        makeNewEpoch();
        pool_index = endIndex();
    }
    _pool[pool_index].setTemp(temp_c);
    emit dataUpdate();
}

void Dataset::mergeGnssTrack(QList<Position> track) {
    const int64_t max_difference_ns = 1e9;
    const int psize = size();
    const int tsize = track.size();
    int track_pos_save = 0;
    volatile int sync_count = 0;

    for(int iepoch = 0; iepoch < psize; iepoch++) {
        Epoch* epoch =  fromIndex(iepoch);
        Position p_internal = epoch->getPositionGNSS();

        DateTime time_epoch = *epoch->time();
        if(time_epoch.sec > 0) {
            p_internal.time = *epoch->time();
            p_internal.time.sec -= 18;
        }

        int64_t internal_ns  = p_internal.time.sec*1e9+p_internal.time.nanoSec;


        if(internal_ns > 0) {
            int64_t min_dif_ns = max_difference_ns;
            int min_ind = -1;
            for(int track_pos = track_pos_save; track_pos < tsize;track_pos++) {
                int64_t track_ns  = track[track_pos].time.sec*1e9+track[track_pos].time.nanoSec;
                if(track_ns > 0) {
                    int64_t dif_ns = track_ns - internal_ns;
                    if(min_dif_ns > abs(dif_ns)) {
                        min_dif_ns = abs(dif_ns);
                        min_ind = track_pos;
                    }

                    if(dif_ns > max_difference_ns) { break; }
                }
            }

            if(min_ind > 0) {
                track_pos_save = min_ind;
                epoch->setExternalPosition(track[min_ind]);
                sync_count++;
            }
        }
    }
    emit dataUpdate();
}


void Dataset::resetDataset() {
    _pool.clear();
    _llaRef.isInit = false;
    _channelsSetup.clear();
    resetDistProcessing();

    clearBoatTrack();
    emit dataUpdate();
}

void Dataset::resetDistProcessing() {
    int pool_size = size();
    for(int i = 0; i < pool_size; i++) {
//        Epoch* dataset = fromIndex(i);
//        dataset->resetDistProccesing();
    }
}

void Dataset::bottomTrackProcessing(int channel1, int channel2, BottomTrackParam param) {
    if(param.indexFrom < 0 || param.indexTo < 0) { return; }

    int epoch_min_index = param.indexFrom - param.windowSize/2;

    if(epoch_min_index < 0) {
        epoch_min_index = 0;
    }

    int epoch_max_index = param.indexTo + param.windowSize/2;
    if(epoch_max_index >= size()) {
        epoch_max_index = size();
    }

    QVector<int32_t> summ;

    float gain_slope = param.gainSlope;
    float threshold = param.threshold;

    int istart = 4;
    int init_win = 6;
    int scale_win = 20;

    int16_t c1 = -6, c2 = 6, c3 = 4, c4 = 2, c5 = 0;
    float s2 = 1.04f, s3 = 1.06f, s4 = 1.10f, s5 = 1.15f;
    float t1 = 1.07;



    if(param.preset == BottomTrackOneBeamNarrow) {
        istart = 4;
        init_win = 6;
        scale_win = 35;

        c1 = -3, c2 = 8, c3 = 5, c4 = -1, c5 = -1;
        s2 = 1.015f, s3 = 1.035f, s4 = 1.08f, s5 = 1.12f;
        t1 = 1.04;
    }


    if(param.preset == BottomTrackSideScan) {
        istart = 4;
        init_win = 6;
        scale_win = 12;

        c1 = -3, c2 = -3, c3 = 4, c4 = 2, c5 = 1;
        s2 = 1.1f, s3 = 1.2f, s4 = 1.3f, s5 = 1.4f;
        t1 = 1.2;
    }

    const int gain_slope_inv = 1000/(gain_slope);
    const int threshold_int = 10*gain_slope_inv*1000*threshold;

    typedef  struct {
        float min = NAN, max = NAN;
    } EpochConstrants;

    QVector<QVector<int32_t>> cash(param.windowSize);
    QVector<EpochConstrants> constr(param.windowSize);

    QVector<float> bottom_track(epoch_max_index - epoch_min_index);
    bottom_track.fill(NAN);

    int epoch_counter = 0;

    for(int iepoch = epoch_min_index; iepoch < epoch_max_index; iepoch++) {
        Epoch* epoch = fromIndex(iepoch);
        if(epoch == NULL || !epoch->chartAvail(channel1)) { continue; }

        epoch_counter++;

        Epoch::Echogram* chart = epoch->chart(channel1);

        uint8_t* data = (uint8_t*)chart->amplitude.constData();
        const int data_size = chart->amplitude.size();

        int cash_ind = (epoch_counter-1)%param.windowSize;

        int back_cash_ind = ((epoch_counter)%param.windowSize);
        int32_t* back_cash_data = (int32_t*)cash[back_cash_ind].constData();
        const int back_cash_size = cash[back_cash_ind].size();

        int32_t* summ_data = (int32_t*)summ.constData();

        if(epoch_counter >= param.windowSize) {
            for(int i = istart; i < back_cash_size; i++) { summ_data[i] -= back_cash_data[i]; }
        }

        if(cash[cash_ind].size() != data_size) {
            cash[cash_ind].resize(data_size);
        }

        int32_t* cash_data = (int32_t*)cash[cash_ind].constData();


        uint8_t* data_from = &data[istart];
        uint8_t* data_to = &data[(istart+init_win)];

        int data_acc = 0;
        for(int idata = istart; idata < (istart+init_win); idata++) {
            data_acc += data[idata];
        }

        int avrg_range = init_win;
        for(int idata = istart; (idata + avrg_range) < data_size; idata++) {
            data_acc -= *data_from; data_from++;
            data_acc += *data_to; data_to++;
            while((idata+(init_win*scale_win)) >= ((avrg_range = data_to - data_from)*scale_win)) {
                data_acc += *data_to; data_to++;
            }
            cash_data[idata] = 10*data_acc / (avrg_range);
        }

        const int data_conv_size = data_size - avrg_range;
        for(int idata = istart; ; idata++) {
            const float fidata = idata + init_win+1;
            int di1 =  idata;
            int di2 =  fidata*s2;
            int di3 =  fidata*s3;
            int di4 =  fidata*s4;
            int di5 =  fidata*s5;

            if(di5 >= data_conv_size) { break; }

            int calc = (c1*cash_data[di1] + c2*cash_data[di2] + c3*cash_data[di3] + c4*cash_data[di4] + c5*cash_data[di5]);
            calc = calc*gain_slope_inv + calc*(idata);

            cash_data[idata] = calc;
        }

        const int col_size = cash[cash_ind].size();
        if(summ.size() < col_size) { summ.resize(col_size); }
        summ_data = (int32_t*)summ.constData();
        for(int i = istart; i < col_size; i++) { summ_data[i] += cash_data[i]; }


        constr[cash_ind].min = chart->bottomProcessing.getMin();
        constr[cash_ind].max = chart->bottomProcessing.getMax();

        const int win_center_index = (epoch_counter - 1 + param.windowSize/2)%param.windowSize;

        float search_from_distance = param.minDistance;
        float search_to_distance = param.maxDistance;

        if(search_from_distance < constr[win_center_index].min) {
            search_from_distance = constr[win_center_index].min;
        }

        if(search_to_distance > constr[win_center_index].max) {
            search_to_distance = constr[win_center_index].max;
        }

        int start_search_index = search_from_distance/t1/chart->resolution;
        int end_search_index = search_to_distance/t1/chart->resolution;

        if(start_search_index < 0) { start_search_index = 0; }
        if(start_search_index > summ.size()) { start_search_index = summ.size(); }

        if(end_search_index < 0) { end_search_index = 0; }
        if(end_search_index > summ.size()) { end_search_index = summ.size(); }


        int max_val = threshold_int*param.windowSize;
        int max_ind = -1;
        for(int i = start_search_index; i < end_search_index ; i++) {
            if(max_val < summ_data[i]) {
                max_val = summ_data[i];
                max_ind = i;
            }
        }

        if(max_ind > 0) {
            float distance = ((max_ind+init_win+1)*t1)*chart->resolution;

            if(epoch_counter >= param.windowSize) {
                if(param.verticalGap > 0) {
                    int32_t* center_cash_data = (int32_t*)cash[win_center_index].constData();
                    const int center_cash_size = cash[win_center_index].size();

                    int start_gap_index = max_ind*(1.0f-param.verticalGap);
                    int end_gap_index = max_ind*(1.0f+param.verticalGap);

                    if(start_gap_index < start_search_index) { start_gap_index = start_search_index; }
                    if(start_gap_index > center_cash_size) { start_gap_index = center_cash_size; }

                    if(end_gap_index < 0) { end_gap_index = 0; }
                    if(end_gap_index > center_cash_size) { end_gap_index = center_cash_size; }
                    if(end_gap_index > end_search_index) { end_gap_index = end_search_index; }

                    int max_gap_val = 0;
                    int max_gap_ind = -1;
                    for(int i = start_gap_index; i < end_gap_index ; i++) {
                        if(max_gap_val < center_cash_data[i]) {
                            max_gap_val = center_cash_data[i];
                            max_gap_ind = i;
                        }
                    }


                    if(max_gap_ind > 0) {
                        distance = ((max_gap_ind+init_win+1)*t1)*chart->resolution;
                    }
                }

                bottom_track[iepoch - epoch_min_index - param.windowSize/2] = distance;
            } else {
                bottom_track[iepoch - epoch_min_index - epoch_counter/2] = distance;
            }
        }
    }


    int epoch_start_index = param.indexFrom;

    if(epoch_start_index < 0) {
        epoch_start_index = 0;
    }

    int epoch_stop_index = param.indexTo;
    if(epoch_stop_index >= size()) {
        epoch_stop_index = size();
    }

    for(int iepoch = epoch_start_index; iepoch < epoch_stop_index; iepoch++) {
        Epoch* epoch = fromIndex(iepoch);

        if(epoch == NULL) { continue; }

        if(epoch->chartAvail(channel1)) {
            Epoch::Echogram* chart = epoch->chart(channel1);
            if(chart->bottomProcessing.source < Epoch::DistProcessing::DistanceSourceDirectHand) {
                float dist = bottom_track[iepoch - epoch_min_index];
                chart->bottomProcessing.setDistance(dist, Epoch::DistProcessing::DistanceSourceProcessing);
            }
        }

        if(epoch->chartAvail(channel2)) {
            Epoch::Echogram* chart = epoch->chart(channel2);
            if(chart->bottomProcessing.source < Epoch::DistProcessing::DistanceSourceDirectHand) {
                float dist = bottom_track[iepoch - epoch_min_index];
                chart->bottomProcessing.setDistance(dist, Epoch::DistProcessing::DistanceSourceProcessing);
            }
        }
    }

    setChannelOffset(channel1, param.offset.x, param.offset.y, param.offset.z);
    spatialProcessing();
    emit dataUpdate();
    lastBottomTrackEpoch_ = size();
    emit bottomTrackUpdated(epoch_min_index, epoch_max_index);
}

void Dataset::spatialProcessing() {
    QList<DatasetChannel> ch_list = channelsList().values();
    for (const auto& channel : ch_list) {
        int ich = channel.channel;

        for(int iepoch = 0; iepoch < size(); iepoch++) {
            Epoch* epoch = fromIndex(iepoch);
            if(epoch == NULL) { continue; }

            Position ext_pos = epoch->getExternalPosition();

            if(epoch->chartAvail(ich)) {
                Epoch::Echogram* data = epoch->chart(ich);

                if(data == NULL) { continue; }

                if(ext_pos.ned.isValid()) {
                    ext_pos.ned.d += channel.localPosition.z;
                }

                if(ext_pos.lla.isValid()) {
                    ext_pos.lla.altitude -= channel.localPosition.z;
                }

                data->sensorPosition = ext_pos;

                if(ext_pos.ned.isValid()) {
                    ext_pos.ned.d += data->bottomProcessing.getDistance();
                }

                if(ext_pos.lla.isValid()) {
                    ext_pos.lla.altitude -= data->bottomProcessing.getDistance();
                }

                data->bottomProcessing.bottomPoint = ext_pos;
            }
        }
    }

    emit dataUpdate();
}

void Dataset::usblProcessing() {
    const int to_size = size();
    int from_index = 0;

    _beaconTrack.clear();
    _beaconTrack1.clear();

    for(int i = from_index; i < to_size; i+=1) {
        Epoch* epoch = fromIndex(i);
        Position pos = epoch->getPositionGNSS();

        // if(pos.lla.isCoordinatesValid() && !pos.ned.isCoordinatesValid()) {
        //     if(!_llaRef.isInit) {
        //         _llaRef = LLARef(pos.lla);
        //     }
        //     pos.LLA2NED(&_llaRef);
        // }

        if(pos.ned.isCoordinatesValid() && epoch->isAttAvail() && epoch->isUsblSolutionAvailable()) {
            double n = pos.ned.n, e = pos.ned.e;

            double yaw = epoch->yaw();
            double azimuth = epoch->usblSolution().azimuth_deg-180;
            double dist = epoch->usblSolution().distance_m;
            double dir = ((yaw + azimuth) + 120);
            double rel_n = dist*cos(qDegreesToRadians(dir));
            double rel_e = dist*sin(qDegreesToRadians(dir));
            if(dist > 50 && azimuth < 10  && azimuth > -10) {
                _beaconTrack.append(QVector3D(n+rel_n, e + rel_e, 0));
            }
            if(dist > 250 && (abs(azimuth)  > 170)) {
                _beaconTrack1.append(QVector3D(n+rel_n, e + rel_e, 0));
            }

        }
    }
}

void Dataset::setRefPosition(int epoch_index) {
    Epoch*  ref_epoch = fromIndex(epoch_index);
    setRefPosition(ref_epoch);
}

void Dataset::setRefPosition(Epoch *ref_epoch) {
    if(ref_epoch == NULL) {
        return;
    }

    Position ref_pos = ref_epoch->getPositionGNSS();

    if(ref_pos.lla.isCoordinatesValid()) {
        _llaRef = LLARef(ref_pos.lla);

        for(int iepoch = 0; iepoch < size(); iepoch++) {
            Epoch* epoch = fromIndex(iepoch);
            if(epoch == NULL) { continue; }
            epoch->setPositionRef(&_llaRef);
        }
    }
}

void Dataset::setRefPositionByFirstValid() {
    Epoch* epoch = getFirstEpochByValidPosition();
    if(epoch == NULL) { return; }

    setRefPosition(epoch);
}

Epoch *Dataset::getFirstEpochByValidPosition() {
    for(int iepoch = 0; iepoch < size(); iepoch++) {
        Epoch* epoch = fromIndex(iepoch);
        if(epoch == NULL) { continue; }
        return epoch;
    }

    return NULL;
}

void Dataset::clearBoatTrack() {
    lastBoatTrackEpoch_ = 0;
    _boatTrack.clear();
    emit dataUpdate();
}

void Dataset::updateBoatTrack(bool update_all) {
    const int to_size = size();
    int from_index = 0;

    if(update_all) {
        _boatTrack.clear();
    } else {
        from_index = lastBoatTrackEpoch_;
    }

    QMap<int, DatasetChannel> ch_list = channelsList();

    for(int i = from_index; i < to_size; i+=1) {
        Epoch* epoch = fromIndex(i);
        Position pos = epoch->getPositionGNSS();

        // if(pos.lla.isCoordinatesValid() && !pos.ned.isCoordinatesValid()) {
        //     if(!_llaRef.isInit) {
        //         _llaRef = LLARef(pos.lla);
        //     }
        //     pos.LLA2NED(&_llaRef);
        // }

        if(pos.ned.isCoordinatesValid()) {
            _boatTrack.append(QVector3D(pos.ned.n,pos.ned.e, 0));
        }
    }

    lastBoatTrackEpoch_ = to_size;

    emit boatTrackUpdated();
}

QStringList Dataset::channelsNameList() {
    QStringList ch_names;
    QList<DatasetChannel> ch_list = channelsList().values();
    ch_names.append(QString("None"));
    ch_names.append(QString("First"));
    for (const auto& channel : ch_list) {
        ch_names.append(QString("%1").arg(channel.channel));
    }
    return ch_names;

}
